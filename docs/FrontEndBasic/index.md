# 前端发展的几个阶段

## (一) 附属时代

1990 年诞生了世界上的第一款浏览器，HTML 作为超文本标记语言被用于在网页中展示文字，但此时的 HTML 仅仅是实验室产品。1994 年，网景公司成立并开发了一款名为 Navigator 的浏览器，HTML 技术得到了推广。

Navigator 浏览器诞生后，CSS、HTML2 和 W3C 联盟相继出现。CSS 誓要给枯燥的图文世界带来一些色彩;W3C 联盟则作为 Web（万维网 World Wide Web）技术和官方代表，致力于制定 Web 技术标准，要求浏览器厂商按照统一标准来实现。

HTML 和 CSS 都属于 Web 技术范畴。

1995 年，网景公司的工程师 Brendan Eich 花了 10 天的时间设 计了 `JavaScript`（简称 JS）语言，并将其内嵌到浏器中。在此期间，微软公司开发出了 IE 浏览器。JavaScript 出现后微软公司又开发了一款脚本语言 `JScript` 嵌入 IE 浏览器中。

第一次浏览器大战后，网景公司战败。但网景公司为了确保 JavaScript 的市场领导地位，已经率先将其提交到 ECMA 进行标准化。随后 ECMA 以 JavaScript 为基础，制定了 ECMAScript 1.0 标准规范(目前已经更新到了 ES6+)。这也是网景公司战败，但是 Javascript 还能继续发展的原因。

至此，Web 领域由 W3C 和 ECMA 两大标准组织推进，Web 开始快速发展。

### 1. 前端的诞生

在 Web 1.0 时代，网页是静态的，并没有前端和后端之分。随着以 ASP、JSP 和 PHP 为代表的动态页面技术的诞生，网站能够从数据库中获取数据并展示出来，因此网站开发逐渐被划分为前端和后端两个方向。

后端开发的主要任务是编写业务逻辑和处理数据;前端开发的工作相对来说比较简单，主要是对文字、图片做排版和样式修饰，并没有非常复杂的交互，以 PHP 为例，网站代码被嵌在一个 MVC 框架中。MVC 即模型(Modal)、视图(View)和控制器(Controller)，其中视图部分代表 HTML 页面。前端开发者将静态页面交给后端开发者，后端开发者将其修改为 PHP 模板放到框架中。此时的前端只是 PHP 的一部分。

随着互联网的快速发展，Web 应用的体量越来越大，前端和后端的代码揉在一起的弊端越来越明显--高耦合、互相影响、难以分模块，共同调试和维护一套代码变得越来越困难。于是，前端的需求高涨。

随着 HTML5 的出现，移动互联网逐渐成为潮流，手机的硬件和性能也越来越好。用户使用手机不再只是看图文，而是希望在手机上通过滑动手指就能完成任何事情。于是有了购物、视频游戏等 App，这些变化推动前端进入爆发期。

尽管如此，前端依然离不开后端，并且是后端项目的一部分。前端页面需要动态数据，因此不管开发了什么功能，最后一步还是要交给后端工程师完成，把页面套在他们的板中。

### 2. jQuery 实现交互

在 Web 1.0 时代，前端的“技术性”体现在 jQuery 上。

在一些交互比较复杂的页面中，需要大量操作 DOM 来实现功能。原生的 JavaScript DOM API 因为以下两方面的原因，使用效率很低:

- 不同浏览器的 API 存在兼容性;
- 原生 API 使用繁琐，没有“链式”和“批量”这样的快捷操作；

在这种情况下，前端迫切需要一种统一、使用简单、操作效率更高的方式来代替原生的 API,此时 jQuery 登场了。

jQuery 的出现带来了巨大便利性。在没有 jQuery 的时候，操作 DOM 全靠原生 API。

jQuery 将原生 API 包装起来，采用一种更简单、直观的方式实现调用。特别是 iQuery 提供的链式调用和批量操作，不仅简单直观，还容易理解，所以前端开发者不愿意再用原生 API 操作 DOM。

jQuery 最强大的功能还是插件系统--可以将一个功能模块封装成插件以供复用。

提示:jQuery 的插件生态非常丰富。在有的网站上可以找到一些常用的组件(如日历、轮播

图、弹框、各种动画、特效)，这些是全球开发者共同的心血，可以完全免费使用，因此大大

提高了开发效率。

jQuery 插件算是最早意义上的组件化--无数的物料以 jQuery 插件的形式在全世界分享，对于此时的前端而言，这是 jQuery 的时代。

## (二) 分家时代

在一些规模较大的 Web 应用中，前端和后端一体开发的弊端逐渐暴露出来，具体表现在以下两个方面:

- **模块划分:**项目代码日渐庞大臃肿，开发者意识到必须通过拆分模块来降低代码的耦合度。然而大部分的视图代码都是前端和后端混在一起的，难以解耦;
- **多人协作:**项目越大，开发者就越多，前端和后端的开发者在一个代码仓库中不断拉取与合并，这本身就是不规范的，很容易引发冲突和覆盖的问题。

此时的 Web 应用已经有分离的趋势，但受制于技术，短期之内无法实现。

### 1. AJAX 出现

2005 年发生了 JavaScript 历史上具有里程碑意义的大事--AJAX 出现了。AJAX 为 JavaScript 带来了异步获取数据的能力，使“不刷新浏览器更新页面状态”成为可能。

对于一些操作性的功能，如提交表单，传统的提交方式会刷新整个页面，如果服务器处理失败，表单就需要重填。但有了 AJAX，就可以在当前页面异步提交，并将服务器响应结果在当前页面提示。

2005 年前后，谷歌发布了两款重量级的 Web 产品，分别为 Gmail 和 GoogleMap。这两款 Web 产品都使用了 AJAX 技术，并且用这种技术开发的大部分页面是异步与服务器进行通信的，操作体验如同使用原生应用那样丝滑。这让开发者意识到，AJAX 可以应用得更广，随后 AJAX 不断在前端中创造价值。这个阶段一些博客论坛广受欢迎，因为用户可以在评论区与作者互动，这大大促进了 Web 2.0 时代的发展。

### 2. 前后端分离

随着 AJAX 的普及，越来越多的前端工程师开始思考:是否可以全部采用 AJAX 与后端交换数据，从而实现前端的完全独立?

假设有一套现成的接口，需要单独开发一个前端程序，先在 Javascript 中调用接口获取数据，再动态渲染 DOM 更新页面。这样，即便前端不依赖 MVC 框架单独部署，也能实现用户的访问操作和线上数据交换。

在实际的应用场景中，虽然可以这样做，但是在一些细节上，会有难以处理的问题，具体表现

为以下两个方面:

- **路由问题：**AJAX 局部更新可以动态改变页面，但并不会导致 URL 地址发生变化。最终的结果可能是经过多次操作切换到某个页面，结果一刷新，页面又切换到最开始的位置;
- **状态问题**：在后端渲染的 MVC 模式下，用户信息被存储在 Session 中，当前用户的登录状态可以直接得到。但在纯前端的环境下，应用是无状态的，如何处理用户登录就成了难题；

在没有通用方案的情况下，传统的 MVC 框架依然是主流。此时的 AJAX 依然是优化用户体验的角色，还没有应用到完整页面的异步更新。

### 3. 三大框架出现并流行

2009 年，谷歌的工程师创建了一个名为 AngularJS 的前端开发框架，并且在该框架中引入了 MVC，依赖注入和模块化的设计思想。

提示:与其他框架不同，AngularS 并不依赖操作 DOM 来更新页面，而是提供了一个很超前的方法，即双向数据绑定。只要把数据绑定到 HTML 上，在数据发生改变时，绑定的数据就会

自动更新。这是最早的数据驱动视图的思想。

2013 年，Facebook 推出了 React 。React 在吸收了 AngularJS 精华的基础上，又创造了虚拟 DOM(Virtual DOM)，一下子突破了复杂页面的性能瓶颈。另外，React 还提供了创新性的 JSX 语法和 Diff 算法。

在 React 推出一年后，出现了 Vue.js 。Vue.js 的开发者尤雨溪是中国人，他以一己之力开发

出来的 Vue.js 足以和 React 媲美。Vue.js 吸收了 AngularJS 和 React 的精华，不仅采用虚拟 DOM，还保留了双向绑定。最重要的是，Vue.js 的 API 设计非常简单，很容易上手因此吸引了大批的开发者使用。另外，Vue.js 的开发文档对国内程序员非常友好，中文表述简单，读起来毫不费劲。

提示:目前，AngularS、React 和 Vue.js 并称为前端三大框架。三大框架互相学习、互相竞

争，不断带来新的思路，推出新功能，共同推动前端前进。

三大框架的出现，彻底改变了前端的开发方式，使前端开发进入完全的前后端分离模式。

这种变革促使后端也发生变化，由开始的嵌套前端页面模板变成纯粹的接口输出，这与 App 的开发方式基本统一。前端从一个 Web 应用的模板正式进化为前端应用。

## (三) 工程化时代

2009 年推出的 AngularJS 加速了前后端分离。2009 年还诞生了另一项对于前端具有革命性意义的技术——Node.js 。Node.js 把客户端脚本语言 JavaScript 应用到了服务端，使其拥有操

作文件和数据库的能力。

Node.js 是一个单线程的、基于事件循环的异步 !/0 框架，基于 Chrome8 引擎，性能卓

越，可以代替传统的 MVC 框架编写后端。Node.js 的 API 使用起来非常简单，只需要几行代码

就能运行一个 Web 服务器。

提示:Node.js 的一大亮点是 Npm 包管理。Npm 可以通过命令快捷地添加和删除第三方包有数百万的第三方包可以免费使用。另外，Node.is 本身只保留了基础功能，其他功能都作为 Npm 包存在，这也使 Node.js 代码非常简单干净，维护起来非常简单。

“**JavaScript 语法、可开发后端、包管理、代码极简**”这几项特点使 Node.js 称为前端最耀眼

的“明星”，开发者纷纷尝试用 Node.js 做一些更酷的事情。

因为 JavaScript 运行在浏览器沙盒环境下，所以没有主动操作文件的权限。Node.is 提供了操作文件的能力后，意味着让代码发生“改变”成为可能。

让代码发生“变化”是“编译”的前提，这正是前端工程化的萌芽。

### 1. Node.js 开启了前端工程

2015 年 Angular JS 创始团队推出了 Angular CLl。Angular CLl 是一款命令行工具，也被叫做脚手架工具，可以通过命令选择模板，快速创建运行项目，使前端可以运行在像`http://localhost:8080`这样的本地服务之下。

Angular CL 通过命令行创建和运行项目，这是前端工程化的开端。但是 Angular CLl 创建和运行项目的基础功能是 Node.js 提供的。Node.js 通过文件 API 生成项目，同时创建本地服务器挂载前端项目，使前端项目始终处在 Node.js 的运行环境之下。

例如，用脚手架创建的项目自带热更新功能。在修改代码并保存后，不需要手动刷新，页面会自动检测到修改并更新。

**原理：**其实是 Node.js 启动了一个 WebSocket 连接，在修改代码时，一旦检测到文件发送变化，就会主动触发编译更新。

提示:很多前端开发者都有过这样一个疑问--什么是前端工程化?

主流的前端工程化是将 Node.js 的功能投射到前端项目上，为前端安装各种“装备”，从而彻底提高前端开发者的开发效率。

### 2. Webpack 带来了编译

Webpack 将操作文件的能力发挥到了极致。

Webpack 是一个现代的 JavaScript 应用程序的打包器。它有两方面的核心作用：

- **打包:** 意味着 Webpack 可以将任意文件模块化，从而在项目中可以通过 import/export 实现文件的导入导出;
- **转换:** 意味着对于 Webpack 不认识的非 JavaScript 文件，通过自定义的 Loader Webpack 认识并处理这个文件；这种转换功能在 Webpack 中，被叫做**编译**。

提示:正因为出现了编译，前端才有了“源码”和“可执行代码”的区别。这在 jQuery 时代是没有的，那时开发编写的代码就是源码，交给浏览器就能直接执行。

### 3. 工程化体系持续完善

Node.is 提供了工程化的基础能力，Webpack 提供了灵活的编译能力，两者强强联合，将大

量的优秀工具链集成到工程化体系中。其中，最具代表性的有以下几个:

- **Babel:** 负责转换 Javascript 语法。它面向 JavaScript，可以将最新的 Javascript 语法转换成 ES5 的标准语法，让绝大部分的浏览器支持。可以说，有了 Babel，就不用担心兼容性可以放心使用最先进的语法;
- **Less/Sass:** 负责生成 CSS 代码。它解决了大部分纯 CSS 不够友好的问题，如支持嵌套语法、定义变量，从而使开发效率和编码体验得到成倍的提升。预处理经过编译后，会转换为普通的 CSS 样式，在 Webpack 中，它们有各自的 loader 来实现代码的转换;
- **ESLint:** 负责检测代码规范。它具有代码规范和检测代码规范两大功能。定义代码规范包括使用单引号还是双引号，代码末尾要不要使用分号，以及什么时候换行等代码风格类的规范在多人团队协作中，代码规范非常重要，但往往每个人的编码风格不同，导致规范难以统一有了 ESLint 的规范检测和格式化，就能很容易地解决这个问题。

提示:前端在后期衍生出了很多工程化技术，如持续集成、CI/CD 和自动化部署等。这些都表

示工程化体系在持续发展，前端也越来越高效和成熟。

## (四) 大前端时代

在前端工程化的方案逐渐趋于成熟后，各公司的视野已经不满足于浏览器应用，而是更大胆地尝试一些“探索边界”的事情,“**跨端**”就成为它们紧盯的下一个目标。

### 1. 多端开发的现状

Web 始于计算机时代，那时的浏览器只能安装在计算机中，PC 端就是前端的全部。

后来，随着移动互联网的兴起，用手机刷新闻和浏览网页成了趋势，移动端 H5 页面成了不可或缺的一项。这时多数的 ToC 项目有 PC 端和 H5 端，供用户在不同的屏幕上浏览。

客户端也是随着移动互联网的兴起开始流行的。客户端刚出现时，就是 Android 和 iOS 端。对于开发者来说，两个端两条线，几乎完全不一样。一家中型互联网公司的技术团队，终端开发者至少有 3 类，分别为前端、Android 和 iOS，这是最基本的配置。

但是客户端开发有一个现实问题--效率慢，成本高。对于一家小型公司来说，如果不是产品强需求，那么一般直接采用前端实现。小型公司也确实想做更好的用户体验，但是因为玩不起客户端，所以只能放弃。

正是在这样的背景下，小程序出现了。小程序内嵌在 App 中，以一种微应用的方式打开，没有网页那样的糟糕的加载体验。权限方面，小程序依靠原生应用提供的 API 能做得更多。最关键的是，小程序是使用 JavaScript 开发的，效率和前端页面基本一致。

提示: 小程序的出现，对于那些“不满意 H5 页面的体验，但没有精力开发原生”的团队来说,是一个极大的惊喜。因此，很多小型公司纷纷投入到小程序开发中。小程序虽然起源于微信,随后被各应用纷纷效仿，如支付宝小程序、抖音小程序、头条小程序等，一时间小程序遍地开花。

然而，小程序的便利也为开发者带来了难题，大型企业的小程序方案虽然大同小异，但是代码互不兼容，如果有开发多端小程序的需求，就不得不为各端单独开发一套代码。

至此，客户端阵营已经囊括了 Web、原生 App 和小程序三大类，细分开来至少有 5 个客户端。多端开发的状况带来了高昂的成本，企业迫切需要降本增效。

### 2. 跨端开发成为趋势

前端在 Web 领域积累了足够丰富的工程方案。既然可以通过 Webpack/Babel 将任意高级语法(如 JSX )转换成 JavaScript 代码，那么是否也可以用同样的方式生成另一套其他平台的代码呢?实现“将一套代码打包成多个应用”的目的。

所以，本着降本增效的目的。一些优秀的解决方案逐渐浮出水面，并选择在社区开源。例如，UniApp、Taro、React Native、Electron、Flutter 等跨端方案被广泛应用，前端有机会从“开发一端”转变为“开发多端”。

提示: 正是因为 JavaScript 有了跨端开发的能力，所以传统前端正在跨步进入大前端时代。在大前端时代，JavaScript 可以用于开发全系客户端(Web、小程序、Android、iOS)。对于-些中小型公司(缺乏专业的原生 App 工程师)来说，使用 JavaScript 是一个再好不过的选择。

当然，大前端不是只有跨端开发，除了常规的前端开发，一些新技术也可以被归属到大前端畴，如图形技术、音/视频技术和 VR 技术，这些技术超出了常规前端开发的范畴，但又表现在前端上，因此也可以作为大前端的一部分。

### 3. 一处代码，多处运行

多端开发的现状和 JavaScript 的优势，催生了以 JavaScript 为主的跨端解决方案，其中有代表性的包括 UniApp、Taro、React Native、Electron、Flutter 等。

#### 一、UniApp

- UniApp 是一款创新的跨平台开发框架，它以 Vue.js 的语法为核心，允许开发者编写一次代码，便能编译运行在 iOS、Android、Web 等不同平台上。UniApp 的设计理念是简化开发流程提高开发效率，同时保持应用的性能和用户体验。
- UniApp 通过其编译器，在编译时将 Vue 语法的代码转换成目标平台的原生代码，实现了真正的“一次编写，多端运行”。它不仅支持 Vue 的所有特性，如组件化、数据绑定和事件处理，还提供了一套完整的 API 来访问设备的功能，如摄像头、位置服务等。
- 此外，UniApp 还提供了一套易于使用的 U1 组件库，帮助开发者快速构建美观且功能丰富的用户界面。随着框架的不断选代和优化，UniApp 已经发展成为跨平台开发领域中的佼佼者，为开发者提供了一个高效、灵活且开放的开发环境。

#### 二、Taro

- Taro 是一个使用 React 语法的跨端开发框架，在编译时期将 React DSL 转换为各端代码从而实现“一码多端”。但从 Taro 3 开始，Taro 团队重构了跨端实现方案，将“**编译时的代码转换**”升级为“**运行时的自定义渲染**”，使其成为一个开放式的跨端框架。
- Taro 3 支持直接引用 Vue.js/React 框架本身的代码。Taro 只做渲染层的逻辑，这就解决了语法兼容问题。因此，Taro 3 支持同时用 React 语法和 Vue.js 语法进行开发，从根本上解决了与 Web 代码隔离的问题。Taro 是目前跨端解决方案中非常优秀的代表。

#### 三、React Native

- Taro 也支持将代码转换为原生 App，而转换为原生 App 的功能是基于 React Native 实现的。React Native 是 React 官方提出的跨端解决方案，主要是将 React 代码生成原生 Android、iOS 应用，是 JavaScript 开发原生 App 的主流方案。
- React Native 也沿用了 React 框架中的虚拟 DOM 方案:只需要编写一套代码，就可以将代码打包成不同平台的 App，这极大地提高了开发效率。另外，相对于全部原生开发的应用来说这种方式的维护成本也相对较低。

#### 四、Electron

- Electron 是开发桌面端应用的框架，使用 JavaScript 开发 Windows 和 Mac 应用程序，VSCode 编辑器就是用 Electron 开发的。
- Electron 框架内部嵌入了` Chromium` 和 Node.js。Chromium 负责界面的渲染，所以应用窗口像 Chrome 浏览器;Node.js 主要关注逻辑部分，负责系统底层能力的调用。Electron 比 React Native 更容易上手，因为它完全屏蔽了原生代码，只使用 Node.js 就可以实现大部分的原生功能，并且更容易集成 Webpack、Vite 等构建工具。

#### 五、Flutter

- Flutter 是 Google 推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码同时运行在 Web、Windows、Mac、iOS、Android、Linux 等六大平台。 Flutter 提供了丰富的组件、接口，开发者可以很快地为 Flutter 添加 Native(即原生开发)来开发应用，可以和平台原生语言混合开发扩展。

## (五) Serverless 时代

### 1. 函数即服务

函数即服务(FaaS)是一种面向函数构建和部署软件的方式，即云函数，是 Serverless 的最终表现形式。以前前端的函数是“本地声明，本地调用”。现在云函数单独部署在云上，供前端远程调用。

在云函数的内部，数据库操作可以被封装成 JavaScript 类和方法。在编写一个云函数时，可以直接调用数据库类的方法来实现数据的增、查、改、删。对于前端来说，这相当于抹掉了接口这一层，同时接口后面的数据库、部署和解析也都统统不用前端开发者关心，前端开发者只需要关注如何编写函数，以及如何实现业务逻辑即可。

云函数的这种新型开发模式，彻底放开了前端开发者的限制。在这种模式下，前端开发者不再只面向前端开发，而是面向整个应用开发。这就要求前端开发者在完成传统前端工作的同时，还要编写云函数，并将云函数和前端结合调试，最终交付一个完整应用。

未来 Serverless 普及后，会再一次打破前后端分离的开发模式，转变为基于 JavaScript 的前后端一体化开发。关于这个方面，目前大型企业也在研究，并且已经退出成熟的框架。阿里巴巴的`Midway.js `和字节跳动的` Modern.js` 都是在一体化开发方向上比较成熟的探索。

提示:从最早的 PHP 模板渲染，到后来的前后端分离，再到未来的前后端一体化开发，正好与“合久必分，分久必合”相吻合。但不同的是，前端一步步发展壮大，逐步走到了应用开发的中心。

### 2. 前后端一体化开发

Faas 带来的开发模式的变革，使创建后端服务像创建一个函数那样简单。在这种“无服务”状态下，前端会发生一次颠覆性的变革。

从诞生之初开始，前端的职责就是围绕浏览器进行面向客户端的 UI 界面开发。虽然后来有了工程化和各种增效工具，但是“为用户开发 U1 界面”的本质没有变。前端对接数据的方式从“模板渲染”变为“接口获取”，但数据的管理一直是由后端开发者负责的。

但在 Faas 模式下，前端开发者除了担负传统的界面开发，还要担负数据库管理的工作(编写云函数操作数据)，此时不再由后端提供接口，数据对接需要前端开发者自己开发和调试，这就要求每个前端开发者必须有全栈开发的能力。

与此同时，市场对于前端开发者的要求也会大大提高。在面向应用开发后，前端开发者首先要转变的是思维模式，要从“应用”的角度而不是“前端”的角度看待问题。一直以来，应用的逻辑中心偏向后端，前端开发者不甚愿意了解业务，对业务方面的思考比较浅薄。Serverless 对前端开发者的全局观和业务思考能力有了更高的要求。

提示:课程的最后，会带着大家一起全栈开发一个综合实战项目，项目的 API 部分使用阿里云的 Serverless 函数计算来实现，可以体验“前端 + Serverless”的全栈开发流程，从头开始实现一个完整的应用，并且配置和编写服务函数和前端对接。

## (六) 本章小结

可以将本章介绍的前端发展的几个时代总结为如下形式:

- 一是附属时代，MVC 模式下的前端;
- 二是分家时代，前后端分离模式下的前端;
- 三是工程化时代，前端工程化的进阶;
- 四是大前端时代，前端在跨端方向的统一;
- 五是 Serverless 时代，面向未来的前后端一体化开发。

当前，前端整体还处于大前端时代，多端开发繁荣，工程化也在不断升级。这个时代的前端一直处在源源不断的变化之中。很多人都在感叹前端新技术更迭太快了，学不动了，此时选择一个方向就变得尤为重要。

Serverless 下的前端会逐渐成为应用开发的主导，对前端开发者的要求也会越来越高。因此，前端不会那么轻易触到天花板，偌大的未知世界还等着我们去探索。
